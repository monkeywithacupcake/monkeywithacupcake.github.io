---
layout: post
title:  "Reflection on 100 Days of Code"
categories: 100DaysofCode
---
**Reflection**:
What can you do in 100 days? The answers are limitless. Committing to 100 days of code was great for both my coding and my larger self.  I never set out to be a developer or master any platform, but I wanted to have the skills to solve problems that I knew existed. Unfortunately, I didn't know where to start to get those skills. Where were they hiding? Behind what wall, encoded in which language?

Before I started the 100 Days of Code, I was familiar with HTML and CSS, maintained a few websites, had created a few applications in python and R (mostly for data fetching, processing, and viewing), and had dipped my toe into swift because I had a "great app idea" to solve a problem. Now, I'm confident that I can solve a few problems in a few languages, and I know enough to not bite off some problems. I understand how some of the ecosystem of web services and mobile applications work. I am still aware that there are languages I haven't touched and may not. *It's as if I can see my little mountains and valleys more clearly, but I also know that the world is bigger.* 

At the beginning of July, I was big-eyed and ready to learn a thousand things. I had unreasonable expectations for my ability to climb up the learning curve and develop new applications. I stumbled onto the #100DaysOfCode community. Looking back, I'm so happy that I did. I've learned a ton, and I've met some great people (online and in person). One hundred days later, I wanted to be in a different place, but I'm happy that I took the path that I have. 

I can list many of the things that I did:

+ brushed up and modernized my HTML and css game
+ coded over a dozen iOS applications based on instructions/tutorials/workbooks to gain skills in swift 
+ developed 2 complete iOS applications from my own ideas (2 are headed to appstore once I convert to Swift 4 and prepare for iOS11)
    + "Crushing It" allows simple tracking of things you want to repeatedly do
    + "My Hats" tracks all the different roles we might have at a given time (boards and what not)
+ made substantial progress on a group travel iOS application also my own idea
    + "Travel Together" is a trip organizer that allows you and your friends to collaborate on trip planning and see your trips in space (map), time (calendar), by type (filterable agenda) and to track who paid for what to divvy up the costs.
+ began a quiz application that is timed to match the curriculum for my kids' schoolwork including: Latin, geography, science, catechism, and grammar
+ progressed up from about rank 500K to about 11K in Hacker Rank
+ learned about a bunch of algorithms to speed up search and sort functions in python3 and javascript
+ encountered pre-processors:
    + fell in love with the pug preprocessor for HTML
    + adapted to SCSS for css
    + stumbled through and eventually understood babel for js
+ earned the front-end developer certificate from free code camp, including creating several little web applications in codepen (that I should revisit)
+ braved the terminal, practicing creating and opening files and conducting simple tasks with bash
+ swam in the sea of extensions/frameworks available via cocoapods, npm, etc. 
+ learned how to use javascript to create interactive applications 
+ expanded my fledgling js skills with reactjs and other libraries - even building 4 test mobile applications with reactnative
+ learned how to use jekyll 
    + transferred my blog from wordpress to jekyll (deleted almost everything in the process)
    + created my 100 Days of Code log in jekyll
    + developed two more websites in jekyll
+ made substantial progress in understanding and actually using git for projects and interacting on github
+ created a twitterbot in python
+ completed an Amazon Serverless workshop and built a tutorial Alexa skill for a simulated IoT device
+ made my first pull requests on public repos using github to start contributing to the open source community

That's probably a fairly complete list. However, it shows one of the characteristics of my 100DaysOfCode that was probably not ideal: I was ALL OVER THE PLACE. It's my nature to be this way. I've always wanted to do everything and do it all right now. I don't recommend following such a haphazard path. There's always another shiny thing. It may even be a better shiny thing. Following one path is beneficial, though, because it is easier to look back on completed work and understand how all the parts fit together. One of the things that I enjoyed most was when I finished my first application for iOS from my own head using swift and was able to run it on my phone. It was pretty simple, but it incorporated things that I had learned from several places and was a complete product. I could not have made it to that feeling, that reward, without focusing for days on just one particular part of one language for one platform. 

Luckily, and perhaps because I started out so ignorant, I benefitted a little from bouncing around because struggling with the semantics of a new language helped me to understand more of the fundamentals of things that I had somehow picked up along the way as practice without truly grasping the foundations. I'll not lie - some of the foundations still evade me. I don't know what they are, or I'd just loook them up. Some things evolved over time - I did not truly grasp classes until about day 80, but I've been using them. I still get nervous when trying to update my fork of a repo on github thinking I'll break everything. 

Some of what I did and learned does not quite fit neatly on the list, like making mental connections between different processes, comparing and contrasting the amount of code required to do different tasks by language, learning the discipline of writing less crappy code, etc. That last one is a bugger, but important. 

Also, there's a whole other laundry list of coding-adjacent things that must be done - creating or finding graphics, choosing color palettes, choosing and applying fonts, understanding how changes in development cycles for hardware and software impact your code delivery, etc. The coding-adjacent set also includes figuring out how to publish and share your work. Developing mobile or Alexa applications requires getting in the respective app stores as a developer. There are surprisingly few places in this great big web that explain what that means and all the steps that an independent developer will need to pass through. The lifecycle of an application is not just coding its features, but cleaning it up, correctly formatting the meta-data, thinking through example/dummy test cases that you can share with reviewers, maintaining version control, and following up on minor changes in source code.

Throughout this journey, I've found that **the community is the best part**. Sure, committing to do something for 100 days is great, and actually following through yields results. That's the premise behind the P90X workout system, right? However, the community is the best. I love the engagement on twitter. Everyone is friendly and encouraging. It's truly beautiful.

As for me, I am going to do another round. This time, I'm going to focus on a few specific goals. In the next 100 days (by Jan 18), I will:
+ finish, beta test, and launch the Travel Together iOS application (swift)
+ finish the refactor for and launch the other two iOS applications that I made (swift) 
+ finish the school quiz application for iOS and android (reactnative) that I've planned out but not coded, beta test, and launch
+ IFF I get past those, I will look at my long list of "like to dos" and see what happens.
